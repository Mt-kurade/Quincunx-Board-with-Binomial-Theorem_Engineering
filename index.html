<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quincunx Board — Aesthetic Simulation</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
    :root{
    --bg-start:#0f172a; /* slate-950 */
    --bg-end:#0b1220; /* deep indigo */
    }
    html,body{height:100%;}
    body{
        font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
        margin:0;
        background: linear-gradient(180deg,var(--bg-start) 0%, #071029 40%, #071227 100%);
        -webkit-font-smoothing:antialiased;
        -moz-osx-font-smoothing:grayscale;
        color: #e6eef8;
    }
    
    
    /* Card and layout */
    .card{
        backdrop-filter: blur(6px) saturate(120%);
        background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
        border: 1px solid rgba(255,255,255,0.04);
        box-shadow: 0 10px 30px rgba(2,6,23,0.6);
        border-radius: 16px;
    }
    
    
    /* Canvas responsive sizing, keep internal resolution fixed for coordinates */
    .canvas-wrap{
        width:100%;
        max-width:760px;
        margin:0 auto;
        display:flex;
        justify-content:center;
        padding:18px;
    }
    canvas{width:100%; height:auto; border-radius:12px; display:block}
    
    
    /* Nice range appearance (subtle) */
    input[type=range]{
        -webkit-appearance:none; height:6px; border-radius:999px; background:linear-gradient(90deg,#334155,#06b6d4);
    }
    input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; width:18px; height:18px; border-radius:999px; background:white; box-shadow: 0 3px 8px rgba(2,6,23,0.5); border:2px solid rgba(0,0,0,0.12)}
    
    
    /* small helper */
    .muted{color:#9fb0c8}
    .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.03)}
    
    
    /* tiny animation for header */
    .logo-dot{width:10px;height:10px;border-radius:999px;background:linear-gradient(90deg,#f97316,#ef4444);box-shadow:0 6px 18px rgba(239,68,68,0.25);display:inline-block;margin-right:8px}
    </style>
</head>
<body>
    <div class="min-h-screen flex items-center justify-center p-6">
    <div class="canvas-wrap">
    <canvas id="simCanvas" width="760" height="820" class="shadow-inner"></canvas>
    </div>
    
    
    <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
    <div class="flex gap-2 items-center">
    <button id="toggleBtn" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-gradient-to-r from-blue-500 to-indigo-600 shadow-lg font-semibold">
    <svg id="playSvg" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="white"><path d="M6.5 5.5v9l7-4.5-7-4.5z" /></svg>
    <span id="toggleText">Start</span>
    </button>
    
    
    <button id="singleDrop" class="px-3 py-2 pill font-medium">Drop 1</button>
    <button id="resetBtn2" class="px-3 py-2 pill font-medium">Reset</button>
    </div>
    
    
    <div class="flex justify-end items-center gap-3">
    <div class="text-right muted text-sm">
    <div>Total balls: <span id="totalCount" class="font-bold">0</span></div>
    <div class="mt-1">Theory: <span id="theoryOn" class="pill">ON</span></div>
    </div>
    </div>
    </div>
    
    
    </div>
    </div>
    
    
    <hr class="my-5 border-transparent" />
    
    
    <div class="grid grid-cols-1 sm:grid-cols-4 gap-4">
    <div>
    <label class="text-xs muted">Speed</label>
    <input id="speedRange" type="range" min="0.25" max="4" step="0.25" value="1">
    <div class="text-sm mt-1">x<span id="speedVal">1</span></div>
    </div>
    
    
    <div>
    <label class="text-xs muted">Rows</label>
    <input id="rowsRange" type="range" min="6" max="16" step="1" value="12">
    <div class="text-sm mt-1"><span id="rowsVal">12</span> rows</div>
    </div>
    
    
    <div>
    <label class="text-xs muted">Probability (p)</label>
    <input id="pRange" type="range" min="0.1" max="0.9" step="0.01" value="0.5">
    <div class="text-sm mt-1">p = <span id="pVal">0.50</span></div>
    </div>
    
    
    <div>
    <label class="text-xs muted">Drop rate</label>
    <input id="rateRange" type="range" min="1" max="60" step="1" value="8">
    <div class="text-sm mt-1"><span id="rateVal">8</span> balls / sec</div>
    </div>
    </div>
    
    
    </div>
    </div>
    <script>
        // --- Configuration Constants ---
        const ROWS = 12;
        const BINS = 13; // 12 rows means 13 possible bin positions (0 to 12)
        const PEG_RADIUS = 4;
        const BALL_RADIUS = 6;
        const SPACING = 40;
        const START_X = 300;
        const START_Y = 80;
        const FUNNEL_Y = 20;

        // --- Global State ---
        let canvas, ctx;
        let isRunning = false;
        let balls = [];
        let bins = Array(BINS).fill(0);
        let speed = 2;
        let probability = 0.5;
        let showTheory = true;

        let animationFrameId = null;
        let ballIntervalId = null;

        // --- Utility Functions ---

        /**
         * Calculates the binomial coefficient C(n, k).
         * @param {number} n - The total number of trials (rows).
         * @param {number} k - The number of successful outcomes (right turns).
         * @returns {number} The binomial coefficient.
         */
        const binomialCoefficient = (n, k) => {
            if (k < 0 || k > n) return 0;
            if (k === 0 || k === n) return 1;

            // Optimization for C(n, k) = C(n, n-k)
            if (k > n / 2) k = n - k;

            let result = 1;
            for (let i = 1; i <= k; i++) {
                result = result * (n - i + 1) / i;
            }
            return result;
        };

        /**
         * Calculates the binomial probability P(X = k).
         * @param {number} n - The number of rows.
         * @param {number} k - The number of right turns.
         * @param {number} p - The probability of turning right.
         * @returns {number} The probability.
         */
        const binomialProbability = (n, k, p) => {
            const q = 1 - p;
            return binomialCoefficient(n, k) * Math.pow(p, k) * Math.pow(q, n - k);
        };

        /**
         * Calculates the theoretical distribution counts for the current total balls.
         * @param {number} totalBalls - The total number of balls dropped so far.
         * @returns {number[]} Array of theoretical counts per bin.
         */
        const getTheoreticalDistribution = (totalBalls) => {
            const theoretical = [];
            // k represents the number of right turns (0 to ROWS)
            for (let k = 0; k <= ROWS; k++) {
                const prob = binomialProbability(ROWS, k, probability);
                theoretical.push(prob * totalBalls);
            }
            return theoretical;
        };

        // --- Ball Class (State/Physics) ---

        class Ball {
            constructor(p) {
                this.x = START_X;
                this.y = FUNNEL_Y;
                this.vy = 0;
                this.row = -1;
                // Col starts at 0, representing the center. Each turn is +/- 0.5
                this.col = 0;
                this.targetX = START_X;
                this.targetY = START_Y;
                this.isMoving = true;
                this.isFalling = true;
                this.binIndex = -1;
                this.probability = p;
                this.currentPegX = START_X; // X position of the peg it is falling towards/from
            }

            update() {
                if (!this.isMoving) return;

                // 1. Initial fall from funnel to first peg
                if (this.isFalling) {
                    this.vy += 0.4; // Simulated gravity
                    this.y += this.vy;

                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.isFalling = false;
                        this.row = 0;
                        this.vy = 0;
                    }
                    return;
                }

                // 2. Movement between pegs
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 2) {
                    // Reached the current target peg
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.row++;

                    if (this.row > ROWS) {
                        // Reached the final bin level
                        this.isMoving = false;
                        // The number of right turns 'k' is directly related to the final column position
                        // k = final_col + ROWS/2
                        const k = this.col + ROWS / 2;
                        this.binIndex = Math.round(k); // Should be an integer 0 to ROWS
                        return;
                    }

                    // Decide direction for the next drop
                    const goRight = Math.random() < this.probability;

                    // k is the number of right steps taken (k=0 to ROWS)
                    const k = goRight ? this.col + 0.5 : this.col - 0.5;

                    // Update internal col tracker to reflect the number of right turns relative to center
                    // col_start = -ROWS/2, col_end = ROWS/2
                    this.col += goRight ? 0.5 : -0.5;


                    // Set new target coordinates for the next row
                    this.targetX = START_X + this.col * SPACING;
                    this.targetY = START_Y + this.row * SPACING;
                } else {
                    // Move towards the target peg (constant speed motion)
                    const speedMultiplier = 4; // Constant movement speed
                    this.x += (dx / dist) * speedMultiplier;
                    this.y += (dy / dist) * speedMultiplier;
                }
            }
        }

        // --- Drawing Functions ---

        /**
         * Draws the pegs of the Quincunx board.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         */
        const drawPegs = (ctx) => {
            // Draw funnel
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(START_X - 20, FUNNEL_Y);
            ctx.lineTo(START_X - 10, START_Y);
            ctx.moveTo(START_X + 20, FUNNEL_Y);
            ctx.lineTo(START_X + 10, START_Y);
            ctx.stroke();

            // Draw pegs
            ctx.fillStyle = '#3b82f6';
            for (let row = 0; row < ROWS; row++) {
                // Determine starting column for this row (e.g., Row 0 starts at col 0)
                // The first peg in row 'r' is always at a horizontal offset of -(r/2) * SPACING
                const startCol = -row / 2;
                for (let i = 0; i <= row; i++) {
                    const colOffset = startCol + i;
                    const x = START_X + colOffset * SPACING;
                    const y = START_Y + row * SPACING;
                    ctx.beginPath();
                    ctx.arc(x, y, PEG_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        };

        /**
         * Draws the current positions of the moving balls.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         * @param {Ball[]} ballsList - The list of active ball objects.
         */
        const drawBalls = (ctx, ballsList) => {
            ballsList.forEach(ball => {
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(ball.x + 2, ball.y + 2, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Draw ball with gradient
                const gradient = ctx.createRadialGradient(
                    ball.x - 2, ball.y - 2, 1,
                    ball.x, ball.y, BALL_RADIUS
                );
                gradient.addColorStop(0, '#fca5a5'); // Light red
                gradient.addColorStop(1, '#ef4444'); // Dark red

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Add highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(ball.x - 2, ball.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        };

        /**
         * Draws the histogram bins and the theoretical distribution line.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         * @param {number[]} binCounts - The current counts in each bin.
         */
        const drawBins = (ctx, binCounts) => {
            const binWidth = SPACING * 0.8;
            const binStartY = START_Y + ROWS * SPACING + 20;
            const totalBalls = binCounts.reduce((a, b) => a + b, 0);
            const theoretical = getTheoreticalDistribution(totalBalls);
            const maxCount = Math.max(...binCounts, ...theoretical, 1);
            const maxHeight = 150;

            // --- Draw theoretical distribution (dashed line) ---
            if (showTheory && totalBalls > 0) {
                ctx.strokeStyle = '#f59e0b'; // Amber
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();

                // The bin index i (0 to BINS-1) corresponds to 'k' right turns (0 to ROWS)
                theoretical.forEach((count, i) => {
                    // Center the point at the middle of the bin position
                    const x = START_X + (i - ROWS / 2) * SPACING;
                    const height = (count / maxCount) * maxHeight;
                    const y = binStartY + maxHeight - height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // --- Draw experimental bins (histogram) ---
            ctx.fillStyle = '#10b981'; // Green
            binCounts.forEach((count, i) => {
                const xCenter = START_X + (i - ROWS / 2) * SPACING;
                const xStart = xCenter - binWidth / 2;
                const height = (count / maxCount) * maxHeight;
                const y = binStartY + maxHeight - height;

                ctx.fillRect(xStart, y, binWidth, height);

                // Draw count label
                if (count > 0) {
                    ctx.fillStyle = '#000';
                    ctx.font = '11px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(count, xCenter, y - 5);
                    ctx.fillStyle = '#10b981';
                }
            });

            // --- Draw bin labels (k values) ---
            ctx.fillStyle = '#64748b';
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            for (let i = 0; i < BINS; i++) {
                const x = START_X + (i - ROWS / 2) * SPACING;
                ctx.fillText(i, x, binStartY + maxHeight + 15);
            }

            // Draw bin separators (vertical lines)
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            for (let i = 0; i < BINS + 1; i++) {
                const x = START_X + (i - ROWS / 2 - 0.5) * SPACING;
                ctx.beginPath();
                ctx.moveTo(x, binStartY);
                ctx.lineTo(x, binStartY + maxHeight + 5);
                ctx.stroke();
            }
        };


        /**
         * Draws the statistical formulas and key values on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         */
        const drawFormula = (ctx) => {
            const totalBalls = bins.reduce((a, b) => a + b, 0);

            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('Binomial Distribution (B(n, p))', 20, 30);

            // Theoretical Formula
            ctx.font = '12px Inter';
            const p = probability.toFixed(2);
            const q = (1 - probability).toFixed(2);
            // $P(X = k) = C(n, k) \cdot p^k \cdot (1-p)^{n-k}$
            ctx.fillText(`P(X = k) = C(${ROWS}, k) × ${p}^k × ${q}^(${ROWS}-k)`, 20, 50);

            // Parameters
            ctx.font = '14px Inter';
            ctx.fillText(`n = ${ROWS} (rows), p = ${p} (probability of right turn)`, 20, 80);

            // Theoretical Moments
            const mean = ROWS * probability;
            const variance = ROWS * probability * (1 - probability);
            const stdDev = Math.sqrt(variance);

            ctx.fillText(`Theoretical Mean (μ): ${mean.toFixed(2)}`, 20, 110);
            ctx.fillText(`Std Deviation (σ): ${stdDev.toFixed(2)}`, 20, 130);

            // Experimental Mean
            if (totalBalls > 0) {
                const expMean = bins.reduce((sum, count, i) => sum + count * i, 0) / totalBalls;
                ctx.fillText(`Experimental Mean: ${expMean.toFixed(2)}`, 20, 160);
            }
        };

        // --- Main Animation Loop ---

        /**
         * The main animation and update loop.
         */
        const animate = () => {
            // 1. Clear canvas and redraw static elements
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);

            // 2. Update and check ball positions
            const updatedBalls = [];
            const newBins = [...bins];

            balls.forEach(ball => {
                ball.update();

                if (!ball.isMoving && ball.binIndex >= 0 && ball.binIndex < BINS) {
                    // Ball has settled into a bin
                    newBins[ball.binIndex]++;
                } else {
                    // Ball is still moving, keep it
                    updatedBalls.push(ball);
                }
            });

            balls = updatedBalls;
            bins = newBins;

            // 3. Draw moving elements
            drawBalls(ctx, balls);
            drawBins(ctx, bins);

            // 4. Update DOM metrics
            document.getElementById('totalBallsCount').textContent = bins.reduce((a, b) => a + b, 0);

            // 5. Request next frame if running
            if (isRunning) {
                animationFrameId = requestAnimationFrame(animate);
            }
        };

        // --- Control Functions ---

        /**
         * Toggles the simulation between running and paused states.
         */
        const handleToggleRun = () => {
            isRunning = !isRunning;
            const runText = document.getElementById('runText');
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            const probabilitySlider = document.getElementById('probabilitySlider');

            if (isRunning) {
                runText.textContent = 'Pause';
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                probabilitySlider.disabled = true; // Lock p value while running
                startBallInterval();
                animate(); // Start the drawing loop
            } else {
                runText.textContent = 'Start';
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                probabilitySlider.disabled = false;
                stopBallInterval();
                cancelAnimationFrame(animationFrameId); // Stop the drawing loop
                // Redraw once to ensure final bins are visible if paused
                drawBins(ctx, bins);
            }
        };

        /**
         * Resets the entire simulation state.
         */
        const handleReset = () => {
            if (isRunning) handleToggleRun(); // Pause first

            balls = [];
            bins = Array(BINS).fill(0);

            // Clear canvas and redraw initial state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);
            drawBins(ctx, bins);

            document.getElementById('totalBallsCount').textContent = 0;
        };

        /**
         * Toggles the visibility of the theoretical distribution line.
         */
        const handleToggleTheory = () => {
            showTheory = !showTheory;
            document.getElementById('theoryState').textContent = showTheory ? 'ON' : 'OFF';
            document.getElementById('theoryToggleBtn').classList.toggle('bg-amber-500', showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('bg-gray-300', !showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('text-white', showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('text-gray-700', !showTheory);

            // Redraw to show/hide the line immediately
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);
            drawBalls(ctx, balls);
            drawBins(ctx, bins);
        };

        /**
         * Starts the interval timer for dropping new balls.
         */
        const startBallInterval = () => {
            if (ballIntervalId) clearInterval(ballIntervalId);
            const dropRateMs = 1000 / speed;
            ballIntervalId = setInterval(() => {
                // Only spawn a new ball if there aren't too many currently active
                if (balls.length < 50) {
                    balls.push(new Ball(probability));
                }
            }, dropRateMs);
        };

        /**
         * Stops the interval timer for dropping new balls.
         */
        const stopBallInterval = () => {
            if (ballIntervalId) {
                clearInterval(ballIntervalId);
                ballIntervalId = null;
            }
        };


        // --- Initialization ---

        const init = () => {
            canvas = document.getElementById('simulationCanvas');
            ctx = canvas.getContext('2d');

            // Set initial appearance
            drawFormula(ctx);
            drawPegs(ctx);
            drawBins(ctx, bins);

            // --- Event Listeners ---

            // Start/Pause Button
            document.getElementById('toggleRunBtn').addEventListener('click', handleToggleRun);

            // Reset Button
            document.getElementById('resetBtn').addEventListener('click', handleReset);

            // Theory Toggle Button
            document.getElementById('theoryToggleBtn').addEventListener('click', handleToggleTheory);

            // Speed Slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValueSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                speed = Number(e.target.value);
                speedValueSpan.textContent = `${speed}x`;
                // If running, restart the interval with the new speed
                if (isRunning) {
                    stopBallInterval();
                    startBallInterval();
                }
            });

            // Probability Slider
            const probabilitySlider = document.getElementById('probabilitySlider');
            const probabilityValueSpan = document.getElementById('probabilityValue');
            probabilitySlider.addEventListener('input', (e) => {
                probability = Number(e.target.value);
                probabilityValueSpan.textContent = probability.toFixed(2);
                // Immediately redraw to update the theoretical line and formula
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFormula(ctx);
                drawPegs(ctx);
                drawBalls(ctx, balls);
                drawBins(ctx, bins);
            });

            // Handle responsiveness (optional, but good practice for canvas)
            const resizeCanvas = () => {
                const rect = canvas.parentNode.getBoundingClientRect();
                // We keep the internal canvas resolution (600x700) constant for consistent drawing coordinates
                // We let CSS scale the canvas to fit the container width
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial call
        };

        // Initialize the application once the window is fully loaded
        window.onload = init;

    </script>
</body>
</html>
