<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quincunx Board Simulation (Galton Board)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics and responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
        }
        .container-wrapper {
            /* Ensures the wrapper uses the minimum screen height and centers content */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #simulationCanvas {
            /* Responsive canvas sizing */
            width: 100%;
            height: auto;
            max-width: 600px;
        }
        .control-button {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .control-button:hover {
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }
    </style>
</head>
<body>

    <div class="container-wrapper bg-gradient-to-br from-slate-100 to-slate-200 p-4 sm:p-8">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-xl">
            <h1 class="text-3xl font-extrabold text-center mb-2 text-blue-700">Quincunx Board (Galton)</h1>
            <p class="text-center text-slate-600 mb-6 font-medium">Binomial vs. Normal Distribution Demonstration</p>

            <!-- Canvas Element -->
            <canvas
                id="simulationCanvas"
                width="600"
                height="700"
                class="border-4 border-slate-300 rounded-lg bg-white mx-auto block"
            ></canvas>

            <!-- Controls -->
            <div class="flex gap-3 mt-6 justify-center items-center flex-wrap">
                <!-- Start/Pause Button -->
                <button
                    id="toggleRunBtn"
                    class="control-button flex items-center gap-2 px-5 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-semibold shadow-lg"
                >
                    <svg id="playIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197 2.132A1 1 0 0110 13.134V8.866a1 1 0 011.555-.832l3.197 2.132a1 1 0 010 1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <svg id="pauseIcon" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="runText">Start</span>
                </button>

                <!-- Reset Button -->
                <button
                    id="resetBtn"
                    class="control-button flex items-center gap-2 px-5 py-2.5 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors font-semibold"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.91 8.91 0 0120 12a9 9 0 11-9-9.914"></path></svg>
                    Reset
                </button>

                <!-- Toggle Theory Button -->
                <button
                    id="theoryToggleBtn"
                    class="control-button flex items-center gap-2 px-5 py-2.5 bg-amber-500 text-white rounded-lg hover:bg-amber-600 transition-colors font-semibold"
                >
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Theory: <span id="theoryState">ON</span>
                </button>
            </div>

            <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-6">
                <!-- Speed Slider -->
                <div>
                    <label for="speedSlider" class="block text-sm font-semibold text-slate-700 mb-2">
                        Ball Drop Speed: <span id="speedValue">2x</span>
                    </label>
                    <input
                        type="range"
                        id="speedSlider"
                        min="1"
                        max="5"
                        value="2"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg"
                    />
                </div>

                <!-- Probability Slider -->
                <div>
                    <label for="probabilitySlider" class="block text-sm font-semibold text-slate-700 mb-2">
                        Probability (p): <span id="probabilityValue">0.50</span>
                    </label>
                    <input
                        type="range"
                        id="probabilitySlider"
                        min="0.1"
                        max="0.9"
                        step="0.05"
                        value="0.5"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg disabled:opacity-50"
                        disabled
                    />
                </div>
            </div>

            <div class="mt-6 text-center text-sm text-slate-600 space-y-1">
                <p>Total balls dropped: <span id="totalBallsCount" class="font-bold">0</span></p>
                <p class="text-xs mt-2">
                    <span class="inline-block w-4 h-3 bg-green-500 mr-1 rounded-sm"></span> Experimental Data (Histogram)
                    <span id="theoryLegend" class="mx-2">
                        <span class="inline-block w-8 h-0.5 bg-amber-500 border-2 border-dashed border-amber-500 mx-2"></span> Theoretical (Binomial)
                    </span>
                </p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration Constants ---
        const ROWS = 12;
        const BINS = 13; // 12 rows means 13 possible bin positions (0 to 12)
        const PEG_RADIUS = 4;
        const BALL_RADIUS = 6;
        const SPACING = 40;
        const START_X = 300;
        const START_Y = 80;
        const FUNNEL_Y = 20;

        // --- Global State ---
        let canvas, ctx;
        let isRunning = false;
        let balls = [];
        let bins = Array(BINS).fill(0);
        let speed = 2;
        let probability = 0.5;
        let showTheory = true;

        let animationFrameId = null;
        let ballIntervalId = null;

        // --- Utility Functions ---

        /**
         * Calculates the binomial coefficient C(n, k).
         * @param {number} n - The total number of trials (rows).
         * @param {number} k - The number of successful outcomes (right turns).
         * @returns {number} The binomial coefficient.
         */
        const binomialCoefficient = (n, k) => {
            if (k < 0 || k > n) return 0;
            if (k === 0 || k === n) return 1;

            // Optimization for C(n, k) = C(n, n-k)
            if (k > n / 2) k = n - k;

            let result = 1;
            for (let i = 1; i <= k; i++) {
                result = result * (n - i + 1) / i;
            }
            return result;
        };

        /**
         * Calculates the binomial probability P(X = k).
         * @param {number} n - The number of rows.
         * @param {number} k - The number of right turns.
         * @param {number} p - The probability of turning right.
         * @returns {number} The probability.
         */
        const binomialProbability = (n, k, p) => {
            const q = 1 - p;
            return binomialCoefficient(n, k) * Math.pow(p, k) * Math.pow(q, n - k);
        };

        /**
         * Calculates the theoretical distribution counts for the current total balls.
         * @param {number} totalBalls - The total number of balls dropped so far.
         * @returns {number[]} Array of theoretical counts per bin.
         */
        const getTheoreticalDistribution = (totalBalls) => {
            const theoretical = [];
            // k represents the number of right turns (0 to ROWS)
            for (let k = 0; k <= ROWS; k++) {
                const prob = binomialProbability(ROWS, k, probability);
                theoretical.push(prob * totalBalls);
            }
            return theoretical;
        };

        // --- Ball Class (State/Physics) ---

        class Ball {
            constructor(p) {
                this.x = START_X;
                this.y = FUNNEL_Y;
                this.vy = 0;
                this.row = -1;
                // Col starts at 0, representing the center. Each turn is +/- 0.5
                this.col = 0;
                this.targetX = START_X;
                this.targetY = START_Y;
                this.isMoving = true;
                this.isFalling = true;
                this.binIndex = -1;
                this.probability = p;
                this.currentPegX = START_X; // X position of the peg it is falling towards/from
            }

            update() {
                if (!this.isMoving) return;

                // 1. Initial fall from funnel to first peg
                if (this.isFalling) {
                    this.vy += 0.4; // Simulated gravity
                    this.y += this.vy;

                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.isFalling = false;
                        this.row = 0;
                        this.vy = 0;
                    }
                    return;
                }

                // 2. Movement between pegs
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 2) {
                    // Reached the current target peg
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.row++;

                    if (this.row > ROWS) {
                        // Reached the final bin level
                        this.isMoving = false;
                        // The number of right turns 'k' is directly related to the final column position
                        // k = final_col + ROWS/2
                        const k = this.col + ROWS / 2;
                        this.binIndex = Math.round(k); // Should be an integer 0 to ROWS
                        return;
                    }

                    // Decide direction for the next drop
                    const goRight = Math.random() < this.probability;

                    // k is the number of right steps taken (k=0 to ROWS)
                    const k = goRight ? this.col + 0.5 : this.col - 0.5;

                    // Update internal col tracker to reflect the number of right turns relative to center
                    // col_start = -ROWS/2, col_end = ROWS/2
                    this.col += goRight ? 0.5 : -0.5;


                    // Set new target coordinates for the next row
                    this.targetX = START_X + this.col * SPACING;
                    this.targetY = START_Y + this.row * SPACING;
                } else {
                    // Move towards the target peg (constant speed motion)
                    const speedMultiplier = 4; // Constant movement speed
                    this.x += (dx / dist) * speedMultiplier;
                    this.y += (dy / dist) * speedMultiplier;
                }
            }
        }

        // --- Drawing Functions ---

        /**
         * Draws the pegs of the Quincunx board.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         */
        const drawPegs = (ctx) => {
            // Draw funnel
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(START_X - 20, FUNNEL_Y);
            ctx.lineTo(START_X - 10, START_Y);
            ctx.moveTo(START_X + 20, FUNNEL_Y);
            ctx.lineTo(START_X + 10, START_Y);
            ctx.stroke();

            // Draw pegs
            ctx.fillStyle = '#3b82f6';
            for (let row = 0; row < ROWS; row++) {
                // Determine starting column for this row (e.g., Row 0 starts at col 0)
                // The first peg in row 'r' is always at a horizontal offset of -(r/2) * SPACING
                const startCol = -row / 2;
                for (let i = 0; i <= row; i++) {
                    const colOffset = startCol + i;
                    const x = START_X + colOffset * SPACING;
                    const y = START_Y + row * SPACING;
                    ctx.beginPath();
                    ctx.arc(x, y, PEG_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        };

        /**
         * Draws the current positions of the moving balls.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         * @param {Ball[]} ballsList - The list of active ball objects.
         */
        const drawBalls = (ctx, ballsList) => {
            ballsList.forEach(ball => {
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.arc(ball.x + 2, ball.y + 2, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Draw ball with gradient
                const gradient = ctx.createRadialGradient(
                    ball.x - 2, ball.y - 2, 1,
                    ball.x, ball.y, BALL_RADIUS
                );
                gradient.addColorStop(0, '#fca5a5'); // Light red
                gradient.addColorStop(1, '#ef4444'); // Dark red

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                // Add highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(ball.x - 2, ball.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        };

        /**
         * Draws the histogram bins and the theoretical distribution line.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         * @param {number[]} binCounts - The current counts in each bin.
         */
        const drawBins = (ctx, binCounts) => {
            const binWidth = SPACING * 0.8;
            const binStartY = START_Y + ROWS * SPACING + 20;
            const totalBalls = binCounts.reduce((a, b) => a + b, 0);
            const theoretical = getTheoreticalDistribution(totalBalls);
            const maxCount = Math.max(...binCounts, ...theoretical, 1);
            const maxHeight = 150;

            // --- Draw theoretical distribution (dashed line) ---
            if (showTheory && totalBalls > 0) {
                ctx.strokeStyle = '#f59e0b'; // Amber
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();

                // The bin index i (0 to BINS-1) corresponds to 'k' right turns (0 to ROWS)
                theoretical.forEach((count, i) => {
                    // Center the point at the middle of the bin position
                    const x = START_X + (i - ROWS / 2) * SPACING;
                    const height = (count / maxCount) * maxHeight;
                    const y = binStartY + maxHeight - height;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // --- Draw experimental bins (histogram) ---
            ctx.fillStyle = '#10b981'; // Green
            binCounts.forEach((count, i) => {
                const xCenter = START_X + (i - ROWS / 2) * SPACING;
                const xStart = xCenter - binWidth / 2;
                const height = (count / maxCount) * maxHeight;
                const y = binStartY + maxHeight - height;

                ctx.fillRect(xStart, y, binWidth, height);

                // Draw count label
                if (count > 0) {
                    ctx.fillStyle = '#000';
                    ctx.font = '11px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(count, xCenter, y - 5);
                    ctx.fillStyle = '#10b981';
                }
            });

            // --- Draw bin labels (k values) ---
            ctx.fillStyle = '#64748b';
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            for (let i = 0; i < BINS; i++) {
                const x = START_X + (i - ROWS / 2) * SPACING;
                ctx.fillText(i, x, binStartY + maxHeight + 15);
            }

            // Draw bin separators (vertical lines)
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            for (let i = 0; i < BINS + 1; i++) {
                const x = START_X + (i - ROWS / 2 - 0.5) * SPACING;
                ctx.beginPath();
                ctx.moveTo(x, binStartY);
                ctx.lineTo(x, binStartY + maxHeight + 5);
                ctx.stroke();
            }
        };


        /**
         * Draws the statistical formulas and key values on the canvas.
         * @param {CanvasRenderingContext2D} ctx - The canvas context.
         */
        const drawFormula = (ctx) => {
            const totalBalls = bins.reduce((a, b) => a + b, 0);

            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('Binomial Distribution (B(n, p))', 20, 30);

            // Theoretical Formula
            ctx.font = '12px Inter';
            const p = probability.toFixed(2);
            const q = (1 - probability).toFixed(2);
            // $P(X = k) = C(n, k) \cdot p^k \cdot (1-p)^{n-k}$
            ctx.fillText(`P(X = k) = C(${ROWS}, k) × ${p}^k × ${q}^(${ROWS}-k)`, 20, 50);

            // Parameters
            ctx.font = '14px Inter';
            ctx.fillText(`n = ${ROWS} (rows), p = ${p} (probability of right turn)`, 20, 80);

            // Theoretical Moments
            const mean = ROWS * probability;
            const variance = ROWS * probability * (1 - probability);
            const stdDev = Math.sqrt(variance);

            ctx.fillText(`Theoretical Mean (μ): ${mean.toFixed(2)}`, 20, 110);
            ctx.fillText(`Std Deviation (σ): ${stdDev.toFixed(2)}`, 20, 130);

            // Experimental Mean
            if (totalBalls > 0) {
                const expMean = bins.reduce((sum, count, i) => sum + count * i, 0) / totalBalls;
                ctx.fillText(`Experimental Mean: ${expMean.toFixed(2)}`, 20, 160);
            }
        };

        // --- Main Animation Loop ---

        /**
         * The main animation and update loop.
         */
        const animate = () => {
            // 1. Clear canvas and redraw static elements
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);

            // 2. Update and check ball positions
            const updatedBalls = [];
            const newBins = [...bins];

            balls.forEach(ball => {
                ball.update();

                if (!ball.isMoving && ball.binIndex >= 0 && ball.binIndex < BINS) {
                    // Ball has settled into a bin
                    newBins[ball.binIndex]++;
                } else {
                    // Ball is still moving, keep it
                    updatedBalls.push(ball);
                }
            });

            balls = updatedBalls;
            bins = newBins;

            // 3. Draw moving elements
            drawBalls(ctx, balls);
            drawBins(ctx, bins);

            // 4. Update DOM metrics
            document.getElementById('totalBallsCount').textContent = bins.reduce((a, b) => a + b, 0);

            // 5. Request next frame if running
            if (isRunning) {
                animationFrameId = requestAnimationFrame(animate);
            }
        };

        // --- Control Functions ---

        /**
         * Toggles the simulation between running and paused states.
         */
        const handleToggleRun = () => {
            isRunning = !isRunning;
            const runText = document.getElementById('runText');
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');
            const probabilitySlider = document.getElementById('probabilitySlider');

            if (isRunning) {
                runText.textContent = 'Pause';
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                probabilitySlider.disabled = true; // Lock p value while running
                startBallInterval();
                animate(); // Start the drawing loop
            } else {
                runText.textContent = 'Start';
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                probabilitySlider.disabled = false;
                stopBallInterval();
                cancelAnimationFrame(animationFrameId); // Stop the drawing loop
                // Redraw once to ensure final bins are visible if paused
                drawBins(ctx, bins);
            }
        };

        /**
         * Resets the entire simulation state.
         */
        const handleReset = () => {
            if (isRunning) handleToggleRun(); // Pause first

            balls = [];
            bins = Array(BINS).fill(0);

            // Clear canvas and redraw initial state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);
            drawBins(ctx, bins);

            document.getElementById('totalBallsCount').textContent = 0;
        };

        /**
         * Toggles the visibility of the theoretical distribution line.
         */
        const handleToggleTheory = () => {
            showTheory = !showTheory;
            document.getElementById('theoryState').textContent = showTheory ? 'ON' : 'OFF';
            document.getElementById('theoryToggleBtn').classList.toggle('bg-amber-500', showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('bg-gray-300', !showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('text-white', showTheory);
            document.getElementById('theoryToggleBtn').classList.toggle('text-gray-700', !showTheory);

            // Redraw to show/hide the line immediately
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFormula(ctx);
            drawPegs(ctx);
            drawBalls(ctx, balls);
            drawBins(ctx, bins);
        };

        /**
         * Starts the interval timer for dropping new balls.
         */
        const startBallInterval = () => {
            if (ballIntervalId) clearInterval(ballIntervalId);
            const dropRateMs = 1000 / speed;
            ballIntervalId = setInterval(() => {
                // Only spawn a new ball if there aren't too many currently active
                if (balls.length < 50) {
                    balls.push(new Ball(probability));
                }
            }, dropRateMs);
        };

        /**
         * Stops the interval timer for dropping new balls.
         */
        const stopBallInterval = () => {
            if (ballIntervalId) {
                clearInterval(ballIntervalId);
                ballIntervalId = null;
            }
        };


        // --- Initialization ---

        const init = () => {
            canvas = document.getElementById('simulationCanvas');
            ctx = canvas.getContext('2d');

            // Set initial appearance
            drawFormula(ctx);
            drawPegs(ctx);
            drawBins(ctx, bins);

            // --- Event Listeners ---

            // Start/Pause Button
            document.getElementById('toggleRunBtn').addEventListener('click', handleToggleRun);

            // Reset Button
            document.getElementById('resetBtn').addEventListener('click', handleReset);

            // Theory Toggle Button
            document.getElementById('theoryToggleBtn').addEventListener('click', handleToggleTheory);

            // Speed Slider
            const speedSlider = document.getElementById('speedSlider');
            const speedValueSpan = document.getElementById('speedValue');
            speedSlider.addEventListener('input', (e) => {
                speed = Number(e.target.value);
                speedValueSpan.textContent = `${speed}x`;
                // If running, restart the interval with the new speed
                if (isRunning) {
                    stopBallInterval();
                    startBallInterval();
                }
            });

            // Probability Slider
            const probabilitySlider = document.getElementById('probabilitySlider');
            const probabilityValueSpan = document.getElementById('probabilityValue');
            probabilitySlider.addEventListener('input', (e) => {
                probability = Number(e.target.value);
                probabilityValueSpan.textContent = probability.toFixed(2);
                // Immediately redraw to update the theoretical line and formula
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawFormula(ctx);
                drawPegs(ctx);
                drawBalls(ctx, balls);
                drawBins(ctx, bins);
            });

            // Handle responsiveness (optional, but good practice for canvas)
            const resizeCanvas = () => {
                const rect = canvas.parentNode.getBoundingClientRect();
                // We keep the internal canvas resolution (600x700) constant for consistent drawing coordinates
                // We let CSS scale the canvas to fit the container width
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial call
        };

        // Initialize the application once the window is fully loaded
        window.onload = init;

    </script>
</body>
</html>
